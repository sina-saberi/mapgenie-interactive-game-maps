//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AssetClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return Success
     */
    asset(gameSlug: string, mapSlug: string, tileName: string, z: number, x: number, y: number, extension: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Asset/{gameSlug}/{mapSlug}/{tileName}/{z}/{x}/{y}.{extension}";
        if (gameSlug === undefined || gameSlug === null)
            throw new Error("The parameter 'gameSlug' must be defined.");
        url_ = url_.replace("{gameSlug}", encodeURIComponent("" + gameSlug));
        if (mapSlug === undefined || mapSlug === null)
            throw new Error("The parameter 'mapSlug' must be defined.");
        url_ = url_.replace("{mapSlug}", encodeURIComponent("" + mapSlug));
        if (tileName === undefined || tileName === null)
            throw new Error("The parameter 'tileName' must be defined.");
        url_ = url_.replace("{tileName}", encodeURIComponent("" + tileName));
        if (z === undefined || z === null)
            throw new Error("The parameter 'z' must be defined.");
        url_ = url_.replace("{z}", encodeURIComponent("" + z));
        if (x === undefined || x === null)
            throw new Error("The parameter 'x' must be defined.");
        url_ = url_.replace("{x}", encodeURIComponent("" + x));
        if (y === undefined || y === null)
            throw new Error("The parameter 'y' must be defined.");
        url_ = url_.replace("{y}", encodeURIComponent("" + y));
        if (extension === undefined || extension === null)
            throw new Error("The parameter 'extension' must be defined.");
        url_ = url_.replace("{extension}", encodeURIComponent("" + extension));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAsset(_response);
        });
    }

    protected processAsset(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    media(fileName: string, extension: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Asset/storage/media/{fileName}.{extension}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (extension === undefined || extension === null)
            throw new Error("The parameter 'extension' must be defined.");
        url_ = url_.replace("{extension}", encodeURIComponent("" + extension));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMedia(_response);
        });
    }

    protected processMedia(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    images(slug: string, name: string, extension: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Asset/images/{slug}/{name}.{extension}";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (extension === undefined || extension === null)
            throw new Error("The parameter 'extension' must be defined.");
        url_ = url_.replace("{extension}", encodeURIComponent("" + extension));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImages(_response);
        });
    }

    protected processImages(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AuthClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginDto | undefined, cancelToken?: CancelToken): Promise<LoginResponseDto> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<LoginResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LoginResponseDto.fromJS(resultData200);
            return Promise.resolve<LoginResponseDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoginResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param action (optional) 
     * @return Success
     */
    auth(action: string | undefined, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Auth?";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuth(_response);
        });
    }

    protected processAuth(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class CategoryClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param gameSlug (optional) 
     * @return Success
     */
    category(gameSlug: string | undefined, slug: string, cancelToken?: CancelToken): Promise<SideBarDto> {
        let url_ = this.baseUrl + "/api/Category/{slug}?";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        if (gameSlug === null)
            throw new Error("The parameter 'gameSlug' cannot be null.");
        else if (gameSlug !== undefined)
            url_ += "gameSlug=" + encodeURIComponent("" + gameSlug) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCategory(_response);
        });
    }

    protected processCategory(response: AxiosResponse): Promise<SideBarDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SideBarDto.fromJS(resultData200);
            return Promise.resolve<SideBarDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SideBarDto>(null as any);
    }
}

export class GameClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return Success
     */
    gameAll( cancelToken?: CancelToken): Promise<GameDto[]> {
        let url_ = this.baseUrl + "/api/Game";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGameAll(_response);
        });
    }

    protected processGameAll(response: AxiosResponse): Promise<GameDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GameDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GameDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    game(body: CreateGameDto | undefined, cancelToken?: CancelToken): Promise<GameDto> {
        let url_ = this.baseUrl + "/api/Game";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGame(_response);
        });
    }

    protected processGame(response: AxiosResponse): Promise<GameDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GameDto.fromJS(resultData200);
            return Promise.resolve<GameDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GameDto>(null as any);
    }
}

export class LocationClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param gameSlug (optional) 
     * @return Success
     */
    location(gameSlug: string | undefined, slug: string, cancelToken?: CancelToken): Promise<LocationCateogryDto[]> {
        let url_ = this.baseUrl + "/api/Location/{slug}?";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        if (gameSlug === null)
            throw new Error("The parameter 'gameSlug' cannot be null.");
        else if (gameSlug !== undefined)
            url_ += "gameSlug=" + encodeURIComponent("" + gameSlug) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLocation(_response);
        });
    }

    protected processLocation(response: AxiosResponse): Promise<LocationCateogryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LocationCateogryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LocationCateogryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LocationCateogryDto[]>(null as any);
    }

    /**
     * @return Success
     */
    locationDetail(id: number, cancelToken?: CancelToken): Promise<LocationDetailDto> {
        let url_ = this.baseUrl + "/api/Location/locationDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLocationDetail(_response);
        });
    }

    protected processLocationDetail(response: AxiosResponse): Promise<LocationDetailDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LocationDetailDto.fromJS(resultData200);
            return Promise.resolve<LocationDetailDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LocationDetailDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    toggle(id: number | undefined, cancelToken?: CancelToken): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Location/toggle?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToggle(_response);
        });
    }

    protected processToggle(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param gameSlug (optional) 
     * @param slug (optional) 
     * @param search (optional) 
     * @return Success
     */
    search(gameSlug: string | undefined, slug: string | undefined, search: string | undefined, cancelToken?: CancelToken): Promise<LocationSearchDto[]> {
        let url_ = this.baseUrl + "/api/Location/search?";
        if (gameSlug === null)
            throw new Error("The parameter 'gameSlug' cannot be null.");
        else if (gameSlug !== undefined)
            url_ += "gameSlug=" + encodeURIComponent("" + gameSlug) + "&";
        if (slug === null)
            throw new Error("The parameter 'slug' cannot be null.");
        else if (slug !== undefined)
            url_ += "slug=" + encodeURIComponent("" + slug) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<LocationSearchDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LocationSearchDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LocationSearchDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LocationSearchDto[]>(null as any);
    }
}

export class MapClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return Success
     */
    map( cancelToken?: CancelToken): Promise<MapDto[]> {
        let url_ = this.baseUrl + "/api/Map";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMap(_response);
        });
    }

    protected processMap(response: AxiosResponse): Promise<MapDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MapDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MapDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MapDto[]>(null as any);
    }

    /**
     * @return Success
     */
    map2(slug: string, cancelToken?: CancelToken): Promise<MapDto[]> {
        let url_ = this.baseUrl + "/api/Map/{slug}";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMap2(_response);
        });
    }

    protected processMap2(response: AxiosResponse): Promise<MapDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MapDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MapDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MapDto[]>(null as any);
    }

    /**
     * @param gameSlug (optional) 
     * @return Success
     */
    detail(gameSlug: string | undefined, slug: string, cancelToken?: CancelToken): Promise<MapDetailDto> {
        let url_ = this.baseUrl + "/api/Map/detail/{slug}?";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        if (gameSlug === null)
            throw new Error("The parameter 'gameSlug' cannot be null.");
        else if (gameSlug !== undefined)
            url_ += "gameSlug=" + encodeURIComponent("" + gameSlug) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetail(_response);
        });
    }

    protected processDetail(response: AxiosResponse): Promise<MapDetailDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MapDetailDto.fromJS(resultData200);
            return Promise.resolve<MapDetailDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MapDetailDto>(null as any);
    }
}

export class MapGenieClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @param files (optional) 
     * @return Success
     */
    mapGenie(slug: string, files: FileParameter[] | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/MapGenie/{slug}";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMapGenie(_response);
        });
    }

    protected processMapGenie(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CategoryDto implements ICategoryDto {
    id!: number;
    title!: string | undefined;
    icon!: string | undefined;
    info!: string | undefined;
    template!: string | undefined;
    order!: number | undefined;
    hasHeatmap!: boolean;
    featuresEnabled!: boolean;
    displayType!: string | undefined;
    ignEnabled!: boolean;
    ignVisible!: boolean;
    visible!: boolean;
    description!: string | undefined;
    locationCount!: number;
    checkedCount!: number;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.icon = _data["icon"];
            this.info = _data["info"];
            this.template = _data["template"];
            this.order = _data["order"];
            this.hasHeatmap = _data["hasHeatmap"];
            this.featuresEnabled = _data["featuresEnabled"];
            this.displayType = _data["displayType"];
            this.ignEnabled = _data["ignEnabled"];
            this.ignVisible = _data["ignVisible"];
            this.visible = _data["visible"];
            this.description = _data["description"];
            this.locationCount = _data["locationCount"];
            this.checkedCount = _data["checkedCount"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["icon"] = this.icon;
        data["info"] = this.info;
        data["template"] = this.template;
        data["order"] = this.order;
        data["hasHeatmap"] = this.hasHeatmap;
        data["featuresEnabled"] = this.featuresEnabled;
        data["displayType"] = this.displayType;
        data["ignEnabled"] = this.ignEnabled;
        data["ignVisible"] = this.ignVisible;
        data["visible"] = this.visible;
        data["description"] = this.description;
        data["locationCount"] = this.locationCount;
        data["checkedCount"] = this.checkedCount;
        return data;
    }
}

export interface ICategoryDto {
    id: number;
    title: string | undefined;
    icon: string | undefined;
    info: string | undefined;
    template: string | undefined;
    order: number | undefined;
    hasHeatmap: boolean;
    featuresEnabled: boolean;
    displayType: string | undefined;
    ignEnabled: boolean;
    ignVisible: boolean;
    visible: boolean;
    description: string | undefined;
    locationCount: number;
    checkedCount: number;
}

export class CreateGameDto implements ICreateGameDto {
    name!: string | undefined;
    slug!: string | undefined;
    description!: string | undefined;

    constructor(data?: ICreateGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateGameDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateGameDto {
    name: string | undefined;
    slug: string | undefined;
    description: string | undefined;
}

export class GameDto implements IGameDto {
    id!: number;
    name!: string | undefined;
    slug!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GameDto {
        data = typeof data === 'object' ? data : {};
        let result = new GameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface IGameDto {
    id: number;
    name: string | undefined;
    slug: string | undefined;
    description: string | undefined;
}

export class GroupedCategoryDto implements IGroupedCategoryDto {
    title!: string | undefined;
    categories!: CategoryDto[] | undefined;

    constructor(data?: IGroupedCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(CategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GroupedCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupedCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGroupedCategoryDto {
    title: string | undefined;
    categories: CategoryDto[] | undefined;
}

export class LocationCateogryDto implements ILocationCateogryDto {
    id!: number;
    title!: string | undefined;
    icon!: string | undefined;
    info!: string | undefined;
    template!: string | undefined;
    displayType!: string | undefined;
    visible!: boolean;
    locations!: LocationDto[] | undefined;

    constructor(data?: ILocationCateogryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.icon = _data["icon"];
            this.info = _data["info"];
            this.template = _data["template"];
            this.displayType = _data["displayType"];
            this.visible = _data["visible"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations!.push(LocationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocationCateogryDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationCateogryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["icon"] = this.icon;
        data["info"] = this.info;
        data["template"] = this.template;
        data["displayType"] = this.displayType;
        data["visible"] = this.visible;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILocationCateogryDto {
    id: number;
    title: string | undefined;
    icon: string | undefined;
    info: string | undefined;
    template: string | undefined;
    displayType: string | undefined;
    visible: boolean;
    locations: LocationDto[] | undefined;
}

export class LocationDetailDto implements ILocationDetailDto {
    categoryTitle!: string | undefined;
    title!: string | undefined;
    description!: string | undefined;
    medias!: MediaDto[] | undefined;

    constructor(data?: ILocationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryTitle = _data["categoryTitle"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["medias"])) {
                this.medias = [] as any;
                for (let item of _data["medias"])
                    this.medias!.push(MediaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryTitle"] = this.categoryTitle;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.medias)) {
            data["medias"] = [];
            for (let item of this.medias)
                data["medias"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILocationDetailDto {
    categoryTitle: string | undefined;
    title: string | undefined;
    description: string | undefined;
    medias: MediaDto[] | undefined;
}

export class LocationDto implements ILocationDto {
    id!: number;
    title!: string | undefined;
    latitude!: number;
    longitude!: number;
    checked!: boolean | undefined;

    constructor(data?: ILocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.checked = _data["checked"];
        }
    }

    static fromJS(data: any): LocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["checked"] = this.checked;
        return data;
    }
}

export interface ILocationDto {
    id: number;
    title: string | undefined;
    latitude: number;
    longitude: number;
    checked: boolean | undefined;
}

export class LocationSearchDto implements ILocationSearchDto {
    id!: number;
    title!: string | undefined;
    latitude!: number;
    longitude!: number;
    description!: string | undefined;

    constructor(data?: ILocationSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): LocationSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["description"] = this.description;
        return data;
    }
}

export interface ILocationSearchDto {
    id: number;
    title: string | undefined;
    latitude: number;
    longitude: number;
    description: string | undefined;
}

export class LoginDto implements ILoginDto {
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginDto {
    email: string | undefined;
    password: string | undefined;
}

export class LoginResponseDto implements ILoginResponseDto {
    accessToken!: string | undefined;
    refreshToken!: string | undefined;
    expiration!: Date;

    constructor(data?: ILoginResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LoginResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILoginResponseDto {
    accessToken: string | undefined;
    refreshToken: string | undefined;
    expiration: Date;
}

export class MapConfigDto implements IMapConfigDto {
    initialZoom!: number;
    startLat!: number;
    startLng!: number;
    tileSets!: TileSetDto[] | undefined;

    constructor(data?: IMapConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.initialZoom = _data["initialZoom"];
            this.startLat = _data["startLat"];
            this.startLng = _data["startLng"];
            if (Array.isArray(_data["tileSets"])) {
                this.tileSets = [] as any;
                for (let item of _data["tileSets"])
                    this.tileSets!.push(TileSetDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MapConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new MapConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["initialZoom"] = this.initialZoom;
        data["startLat"] = this.startLat;
        data["startLng"] = this.startLng;
        if (Array.isArray(this.tileSets)) {
            data["tileSets"] = [];
            for (let item of this.tileSets)
                data["tileSets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMapConfigDto {
    initialZoom: number;
    startLat: number;
    startLng: number;
    tileSets: TileSetDto[] | undefined;
}

export class MapDetailDto implements IMapDetailDto {
    name!: string | undefined;
    description!: string | undefined;
    slug!: string | undefined;
    config!: MapConfigDto;

    constructor(data?: IMapDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.config = _data["config"] ? MapConfigDto.fromJS(_data["config"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MapDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MapDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["config"] = this.config ? this.config.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMapDetailDto {
    name: string | undefined;
    description: string | undefined;
    slug: string | undefined;
    config: MapConfigDto;
}

export class MapDto implements IMapDto {
    name!: string | undefined;
    description!: string | undefined;
    slug!: string | undefined;

    constructor(data?: IMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): MapDto {
        data = typeof data === 'object' ? data : {};
        let result = new MapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["slug"] = this.slug;
        return data;
    }
}

export interface IMapDto {
    name: string | undefined;
    description: string | undefined;
    slug: string | undefined;
}

export class MediaDto implements IMediaDto {
    title!: string | undefined;
    fileName!: string | undefined;
    type!: string | undefined;
    mimeType!: string | undefined;

    constructor(data?: IMediaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.fileName = _data["fileName"];
            this.type = _data["type"];
            this.mimeType = _data["mimeType"];
        }
    }

    static fromJS(data: any): MediaDto {
        data = typeof data === 'object' ? data : {};
        let result = new MediaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["fileName"] = this.fileName;
        data["type"] = this.type;
        data["mimeType"] = this.mimeType;
        return data;
    }
}

export interface IMediaDto {
    title: string | undefined;
    fileName: string | undefined;
    type: string | undefined;
    mimeType: string | undefined;
}

export class RegisterDto implements IRegisterDto {
    username!: string | undefined;
    email!: string | undefined;
    password!: string | undefined;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterDto {
    username: string | undefined;
    email: string | undefined;
    password: string | undefined;
}

export class SideBarDto implements ISideBarDto {
    locationCount!: number;
    checkedCount!: number;
    groups!: GroupedCategoryDto[] | undefined;

    constructor(data?: ISideBarDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationCount = _data["locationCount"];
            this.checkedCount = _data["checkedCount"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(GroupedCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SideBarDto {
        data = typeof data === 'object' ? data : {};
        let result = new SideBarDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationCount"] = this.locationCount;
        data["checkedCount"] = this.checkedCount;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISideBarDto {
    locationCount: number;
    checkedCount: number;
    groups: GroupedCategoryDto[] | undefined;
}

export class TileSetDto implements ITileSetDto {
    name!: string | undefined;
    extension!: string | undefined;
    pattern!: string | undefined;
    minZoom!: number;
    maxZoom!: number;

    constructor(data?: ITileSetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.extension = _data["extension"];
            this.pattern = _data["pattern"];
            this.minZoom = _data["minZoom"];
            this.maxZoom = _data["maxZoom"];
        }
    }

    static fromJS(data: any): TileSetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TileSetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["extension"] = this.extension;
        data["pattern"] = this.pattern;
        data["minZoom"] = this.minZoom;
        data["maxZoom"] = this.maxZoom;
        return data;
    }
}

export interface ITileSetDto {
    name: string | undefined;
    extension: string | undefined;
    pattern: string | undefined;
    minZoom: number;
    maxZoom: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}